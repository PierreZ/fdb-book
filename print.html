<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>the FoundationDB Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <script defer data-domain="pierrez.github.io/fdb-book" src="https://plausible.io/js/plausible.js"></script>                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">the FoundationDB Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PierreZ/fdb-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="FDB_logo.png" alt="FDB_logo.png" /></p>
<h1 id="the-foundationdb-book-"><a class="header" href="#the-foundationdb-book-">The FoundationDB Book üìñ</a></h1>
<p>Welcome! Whether you're building your own datastore with FoundationDB or are simply curious about its capabilities, you've come to the right place.</p>
<p>üöß This book is a work in progress. We welcome contributions! Feel free to <a href="https://github.com/PierreZ/fdb-book">open a pull request</a> with your improvements. üöß</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h2>
<p>This book is for developers, architects, and database enthusiasts who want to understand and leverage FoundationDB. It serves as a comprehensive guide, linking to the <a href="https://apple.github.io/foundationdb/">official documentation</a> and the <a href="https://forums.foundationdb.org/">community forum</a> when deeper dives are needed.</p>
<h2 id="what-this-book-covers"><a class="header" href="#what-this-book-covers">What This Book Covers</a></h2>
<ul>
<li><strong>Meet FoundationDB:</strong> We start with an introduction to FoundationDB, exploring what makes it unique and why it might be the right choice for your project.</li>
<li><strong>Getting Started:</strong> A hands-on guide to installing FoundationDB and interacting with it using the <code>fdbcli</code> command-line tool.</li>
<li><strong>Developing a Layer:</strong> Learn the core concepts of building on FDB, from ACID transactions to best practices for data modeling and key design. We'll also look at existing open-source layers for inspiration.</li>
<li><strong>FoundationDB's Internals:</strong> Delve into the architecture of FoundationDB, including its read/write paths and powerful simulation framework.</li>
<li><strong>The Record Layer:</strong> A dedicated look at the Record Layer, a Java library from Apple for building complex data models on FoundationDB.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meet-foundationdb"><a class="header" href="#meet-foundationdb">Meet FoundationDB</a></h1>
<p>This section provides a quick introduction to FoundationDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enter-foundationdb"><a class="header" href="#enter-foundationdb">Enter FoundationDB</a></h1>
<ul>
<li><a href="meet_fdb/enter_fdb.html#the-core-an-ordered-transactional-key-value-store">The Core: An Ordered, Transactional Key-Value Store</a>
<ul>
<li><a href="meet_fdb/enter_fdb.html#multi-key-acid-transactions">Multi-Key ACID Transactions</a></li>
</ul>
</li>
<li><a href="meet_fdb/enter_fdb.html#the-powerhouse-performance-and-reliability">The Powerhouse: Performance and Reliability</a></li>
<li><a href="meet_fdb/enter_fdb.html#the-ecosystem-a-foundation-for-layers">The Ecosystem: A Foundation for Layers</a></li>
<li><a href="meet_fdb/enter_fdb.html#a-brief-history">A Brief History</a></li>
<li><a href="meet_fdb/enter_fdb.html#who-uses-foundationdb">Who Uses FoundationDB?</a></li>
<li><a href="meet_fdb/enter_fdb.html#tldr">TL;DR</a></li>
</ul>
<p>As the <a href="https://apple.github.io/foundationdb/">official overview</a> puts it:</p>
<blockquote>
<p>FoundationDB is a distributed database designed to handle large volumes of structured data across clusters of commodity servers. It organizes data as an ordered key-value store and employs ACID transactions for all operations. It is especially well-suited for read/write workloads but also has excellent performance for write-intensive workloads.</p>
</blockquote>
<p>Let's unpack what makes FoundationDB unique.</p>
<h2 id="the-core-an-ordered-transactional-key-value-store"><a class="header" href="#the-core-an-ordered-transactional-key-value-store">The Core: An Ordered, Transactional Key-Value Store</a></h2>
<p>At its heart, FoundationDB is a distributed, open-source (Apache 2.0) key-value store. Think of it as a massive, sorted dictionary where both keys and values are simple byte strings.</p>
<p>The keys are stored in lexicographical order, which means you can efficiently scan ranges of keys. This simple but powerful feature is the basis for building complex data models. For example:</p>
<ul>
<li><code>'user:alice'</code> comes before <code>'user:bob'</code></li>
<li><code>'user:bob'</code> comes before <code>'user:bob:profile'</code></li>
<li>All keys prefixed with <code>'table1:'</code> are grouped together, allowing you to simulate rows in a table.</li>
</ul>
<h3 id="multi-key-acid-transactions"><a class="header" href="#multi-key-acid-transactions">Multi-Key ACID Transactions</a></h3>
<p>The most important feature of FoundationDB is its support for <strong>multi-key, strictly serializable transactions</strong>. This is a rare and powerful guarantee for a distributed database.</p>
<ul>
<li><strong>Transactions:</strong> All operations, including reads and writes, are performed within a transaction. These transactions are fully ACID (Atomic, Consistent, Isolated, and Durable), even across multiple machines.</li>
<li><strong>Multi-Key:</strong> A single transaction can read and write multiple, unrelated keys, no matter where they are stored in the cluster.</li>
<li><strong>Strictly Serializable:</strong> This is the strongest isolation level. It ensures that the result of concurrent transactions is equivalent to them running one at a time in some sequential order. This makes writing correct applications dramatically simpler, as you are protected from a wide range of subtle race conditions.</li>
</ul>
<p>You can find a full list of <a href="https://apple.github.io/foundationdb/features.html">features</a> and, just as importantly, <a href="https://apple.github.io/foundationdb/anti-features.html">anti-features</a> in the official documentation.</p>
<h2 id="the-powerhouse-performance-and-reliability"><a class="header" href="#the-powerhouse-performance-and-reliability">The Powerhouse: Performance and Reliability</a></h2>
<p>FoundationDB is not just a theoretical model; it's a battle-tested engine built for performance and reliability on commodity hardware.</p>
<ul>
<li><strong>Performance:</strong> It delivers linear scalability and high performance, often achieving millions of operations per second on a cluster. You can expect sub-millisecond latencies for many workloads without any special tuning.</li>
<li><strong>Reliability:</strong> It is designed to be fault-tolerant, easy to manage, and simple to grow. Its reliability is backed by an unmatched testing system based on a <strong>deterministic simulation engine</strong>, which we will explore later in this book.</li>
</ul>
<p><img src="https://apple.github.io/foundationdb/_images/scaling.png" alt="FoundationDB Performance Scaling" /></p>
<blockquote>
<p>A cluster of commodity hardware scaling to 8.2 million operations/sec on a 90% read, 10% write workload.</p>
</blockquote>
<h2 id="the-ecosystem-a-foundation-for-layers"><a class="header" href="#the-ecosystem-a-foundation-for-layers">The Ecosystem: A Foundation for Layers</a></h2>
<p>Because FoundationDB provides such a powerful and reliable core, it can serve as a universal storage engine‚Äîa foundation for building other data models. These are called <strong>"layers."</strong></p>
<p>A layer is a stateless component that maps a high-level data model (like a document, graph, or relational model) to FoundationDB's simple key-value model.</p>
<pre class="mermaid">graph TD
    subgraph &quot;Your Application&quot;
        l1(&quot;Document Layer&quot;)
        l2(&quot;Graph Layer&quot;)
        l3(&quot;Queue Layer&quot;)
    end

    subgraph &quot;FoundationDB Cluster&quot;
        fdb[(&quot;Ordered Key-Value Store&lt;br/&gt;ACID Transactions&quot;)]
    end

    l1 -- &quot;stores data in&quot; --&gt; fdb
    l2 -- &quot;stores data in&quot; --&gt; fdb
    l3 -- &quot;stores data in&quot; --&gt; fdb
</pre>
<p>This architecture decouples the data model from data storage, allowing developers to focus on building features without reinventing the complexities of a distributed database.</p>
<h2 id="a-brief-history"><a class="header" href="#a-brief-history">A Brief History</a></h2>
<p>FoundationDB began as a company in 2009. After a successful beta program, version 1.0 was released in 2013. Apple acquired the company in 2015 and subsequently open-sourced the project under the Apache 2.0 license in 2018, making it available to the wider community.</p>
<h2 id="who-uses-foundationdb"><a class="header" href="#who-uses-foundationdb">Who Uses FoundationDB?</a></h2>
<p>FoundationDB is the storage engine behind critical systems at major technology companies, including:</p>
<ul>
<li><strong>Apple:</strong> A massive-scale deployment for iCloud, where it stores billions of logical databases.</li>
<li><strong>Snowflake:</strong> Stores all metadata for its cloud data platform.</li>
<li><strong>VMware:</strong> Used in the Tanzu observability platform.</li>
<li>And many others, including <strong>IBM</strong>, <strong>eBay</strong>, and <strong>Epic Games</strong>.</li>
</ul>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>FoundationDB is a scalable, distributed key-value store with strictly serializable ACID transactions. It's so powerful and reliable that it serves as a universal foundation for building any data model you can imagine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yet-another-database"><a class="header" href="#yet-another-database">Yet Another Database?</a></h1>
<ul>
<li><a href="meet_fdb/another_db.html#how-are-databases-different">How Are Databases Different?</a></li>
<li><a href="meet_fdb/another_db.html#the-rise-of-polyglot-persistence">The Rise of Polyglot Persistence</a></li>
<li><a href="meet_fdb/another_db.html#the-anatomy-of-a-datastore">The Anatomy of a Datastore</a></li>
<li><a href="meet_fdb/another_db.html#the-case-for-a-shared-storage-engine">The Case for a Shared Storage Engine</a></li>
<li><a href="meet_fdb/another_db.html#requirements-for-a-universal-storage-engine">Requirements for a Universal Storage Engine</a></li>
</ul>
<blockquote>
<p>"Another database? There are so many of them!"</p>
</blockquote>
<p>You're right. We live in a golden age of data, which means we have a dizzying number of options for storing it.</p>
<p>According to the <a href="https://dbdb.io/">Database of Databases</a>, there are nearly <strong>800 different database management systems</strong> to choose from. This abundance of choice can be overwhelming.</p>
<h2 id="how-are-databases-different"><a class="header" href="#how-are-databases-different">How Are Databases Different?</a></h2>
<p>When choosing a database, engineers evaluate them against a long list of criteria. This leads to a wide variety of <strong>specialized datastores</strong>, each optimized for a different purpose. Key differentiators include:</p>
<ul>
<li><strong>Data Model:</strong> Is it a document, column-family, key-value, graph, or relational database?</li>
<li><strong>Workload:</strong> Is it designed for transactional (OLTP) or analytical (OLAP) workloads?</li>
<li><strong>Architecture:</strong> Is it embedded, single-node, or distributed?</li>
<li><strong>Transactions:</strong> Does it support ACID transactions?</li>
<li><strong>Query Language:</strong> Does it use SQL or a proprietary language?</li>
<li><strong>Scalability:</strong> What are its performance limits?</li>
<li><strong>Licensing:</strong> Is it open-source?</li>
<li><strong>Features:</strong> Does it offer secondary indexes, stored procedures, or materialized views?</li>
</ul>
<h2 id="the-rise-of-polyglot-persistence"><a class="header" href="#the-rise-of-polyglot-persistence">The Rise of Polyglot Persistence</a></h2>
<p>This variety of specialized datastores leads developers to use multiple databases in a single application‚Äîa pattern sometimes called "polyglot persistence."</p>
<p>For example, a project might require both a relational database for transactional data and a dedicated search index for text search.</p>
<p>Because managing state is complex, a common architectural pattern is to build <strong>stateless applications</strong> that delegate the complexity of data storage to these specialized, stateful databases.</p>
<p>A typical architecture might look like this:</p>
<pre class="mermaid">flowchart TD
    app(&quot;Stateless Application&quot;)
    db1(&quot;Datastore 1 (e.g., PostgreSQL)&quot;)
    db2(&quot;Datastore 2 (e.g., Elasticsearch)&quot;)

    app -- uses --&gt; db1
    app -- uses --&gt; db2
</pre>
<h2 id="the-anatomy-of-a-datastore"><a class="header" href="#the-anatomy-of-a-datastore">The Anatomy of a Datastore</a></h2>
<p>While databases differ in many ways, we can simplify their architecture into three core components:</p>
<ul>
<li>The <strong>Query Language:</strong> The interface for interacting with the data.</li>
<li>The <strong>Data Model:</strong> The way the data is structured and presented (e.g., relational, document).</li>
<li>The <strong>Storage Engine:</strong> The underlying component responsible for durably storing and retrieving data on disk.</li>
</ul>
<p>For example, PostgreSQL exposes a relational data model via the SQL query language, all running on a storage engine designed for a single node.</p>
<p>Let's update our diagram to show this breakdown:</p>
<pre class="mermaid">flowchart TD
    subgraph &quot;System Architecture&quot;
        app(&quot;Stateless Application&quot;)

        subgraph &quot;Datastore 1&quot;
            ql1(&quot;Query Language 1&quot;) --&gt; dm1(&quot;Data Model 1&quot;) --&gt; se1(&quot;Storage Engine 1&quot;)
        end

        subgraph &quot;Datastore 2&quot;
            ql2(&quot;Query Language 2&quot;) --&gt; dm2(&quot;Data Model 2&quot;) --&gt; se2(&quot;Storage Engine 2&quot;)
        end

        app -- &quot;uses&quot; --&gt; ql1
        app -- &quot;uses&quot; --&gt; ql2
    end
</pre>
<p>While the query language and data model are often specialized for a particular use case, what if we could consolidate the storage layer?</p>
<h2 id="the-case-for-a-shared-storage-engine"><a class="header" href="#the-case-for-a-shared-storage-engine">The Case for a Shared Storage Engine</a></h2>
<p>Let's imagine we could use a single, powerful storage engine for all our data models.</p>
<pre class="mermaid">flowchart TD
    subgraph &quot;System Architecture&quot;
        app(&quot;Stateless Application&quot;)

        subgraph &quot;Stateless Data Layer 1&quot;
            ql1(&quot;Query Language 1&quot;) --&gt; dm1(&quot;Data Model 1&quot;)
        end

        subgraph &quot;Stateless Data Layer 2&quot;
            ql2(&quot;Query Language 2&quot;) --&gt; dm2(&quot;Data Model 2&quot;)
        end

        se(&quot;Shared Storage Engine&quot;)

        app -- &quot;uses&quot; --&gt; ql1
        app -- &quot;uses&quot; --&gt; ql2

        dm1 -- &quot;stores data in&quot; --&gt; se
        dm2 -- &quot;stores data in&quot; --&gt; se
    end
</pre>
<p>This design has powerful advantages:</p>
<ul>
<li><strong>Operational Simplicity:</strong> We only need to manage, scale, and back up one underlying storage system.</li>
<li><strong>Stateless Components:</strong> The layers that provide the data models and query languages can themselves become stateless, simplifying their development and deployment.</li>
</ul>
<p>However, this places a heavy burden on the shared storage engine. What would it need to provide?</p>
<h2 id="requirements-for-a-universal-storage-engine"><a class="header" href="#requirements-for-a-universal-storage-engine">Requirements for a Universal Storage Engine</a></h2>
<p>To be a viable foundation for modern, cloud-native applications, such an engine must be:</p>
<ul>
<li><strong>Scalable, Fault-Tolerant, and Highly Available:</strong> It must handle growing workloads and survive hardware failures without downtime.</li>
<li><strong>Transactional:</strong> It must provide strong consistency guarantees (like ACID) to allow developers to reason about their data correctly.</li>
<li><strong>Unopinionated:</strong> It should impose a minimal, flexible data model (like an ordered key-value store) to support various data structures on top.</li>
</ul>
<p>Can such a storage engine exist? <strong>Yes.</strong> It's called FoundationDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modeling-on-a-key-value-store"><a class="header" href="#modeling-on-a-key-value-store">Modeling on a Key-Value Store</a></h1>
<ul>
<li><a href="meet_fdb/everything_is_kv.html#the-pattern-a-tale-of-two-layers">The Pattern: A Tale of Two Layers</a></li>
<li><a href="meet_fdb/everything_is_kv.html#industry-examples">Industry Examples</a>
<ul>
<li><a href="meet_fdb/everything_is_kv.html#sql-on-key-value-google-cockroachdb-and-tidb">SQL on Key-Value: Google, CockroachDB, and TiDB</a></li>
<li><a href="meet_fdb/everything_is_kv.html#advanced-indexing-on-key-value">Advanced Indexing on Key-Value</a></li>
<li><a href="meet_fdb/everything_is_kv.html#multi-model-databases-cosmos-db-and-yugabytedb">Multi-Model Databases: Cosmos DB and YugabyteDB</a></li>
</ul>
</li>
<li><a href="meet_fdb/everything_is_kv.html#the-unbundled-database-foundationdb">The Unbundled Database: FoundationDB</a></li>
</ul>
<blockquote>
<p>"If FoundationDB is just a key-value store, how can it power complex applications?"</p>
</blockquote>
<p>This is the crucial question. The answer lies in a powerful, common architectural pattern: building rich data models on top of a simple, ordered key-value core. By defining a specific way to encode data structures into keys and values, you can represent almost anything, from relational tables to complex documents and graphs.</p>
<p>This is not a new or niche idea. Many of the most successful and scalable modern databases are built using this exact layered architecture. Let's look at a few examples.</p>
<h2 id="the-pattern-a-tale-of-two-layers"><a class="header" href="#the-pattern-a-tale-of-two-layers">The Pattern: A Tale of Two Layers</a></h2>
<p>Most modern databases can be conceptually divided into two layers:</p>
<ol>
<li><strong>The Storage Layer:</strong> A low-level engine, often a key-value store, responsible for the distributed storage, replication, and transactional integrity of data.</li>
<li><strong>The Data Model Layer:</strong> A higher-level component that exposes a rich data model (e.g., SQL, Document, Graph) and translates queries into operations on the underlying storage layer.</li>
</ol>
<p>This separation of concerns allows each layer to do what it does best.</p>
<h2 id="industry-examples"><a class="header" href="#industry-examples">Industry Examples</a></h2>
<p>This layered pattern appears again and again in the architecture of leading databases.</p>
<h3 id="sql-on-key-value-google-cockroachdb-and-tidb"><a class="header" href="#sql-on-key-value-google-cockroachdb-and-tidb">SQL on Key-Value: Google, CockroachDB, and TiDB</a></h3>
<p>Several of the most prominent distributed SQL databases are built on a key-value core.</p>
<ul>
<li>
<p><strong>Google's Spanner and F1:</strong> Google's database journey shows a clear evolution. <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36971.pdf">Megastore</a> provided ACID semantics on top of the Bigtable key-value store. This evolved into <a href="https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf">Spanner</a>, which started as a key-value store and grew into a full-fledged <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/acac3b090a577348a7106d09c051c493298ccb1d.pdf">relational database</a>. The key insight is that the SQL data model is a layer on top of a scalable, transactional key-value foundation.</p>
</li>
<li>
<p><strong>CockroachDB:</strong> As described in their architecture documentation, CockroachDB maps all <a href="https://www.cockroachlabs.com/blog/sql-in-cockroachdb-mapping-table-data-to-key-value-storage/">SQL table and index data</a> directly into its underlying monolithic sorted key-value map.</p>
</li>
<li>
<p><strong>TiDB:</strong> The TiDB ecosystem explicitly separates its components. <a href="https://www.vldb.org/pvldb/vol13/p3072-huang.pdf">TiDB</a> is the SQL computation layer, while <strong>TiKV</strong> is the distributed, transactional key-value storage layer. Each SQL row is mapped to a key-value pair in TiKV.</p>
</li>
</ul>
<h3 id="advanced-indexing-on-key-value"><a class="header" href="#advanced-indexing-on-key-value">Advanced Indexing on Key-Value</a></h3>
<p>The layered pattern extends beyond just mapping primary table data. Even sophisticated secondary indexing strategies, like those for semi-structured data (JSON) or full-text search, are implemented by modeling the index as a set of key-value pairs.</p>
<ul>
<li>
<p><strong>CockroachDB's Inverted Indexes:</strong> To allow efficient querying of JSON or array data types, CockroachDB implements <a href="https://raw.githubusercontent.com/cockroachdb/cockroach/refs/heads/master/docs/RFCS/20171020_inverted_indexes.md">inverted indexes</a>. Instead of storing a single key for the whole JSON document, it tokenizes the document and creates multiple key-value entries mapping individual values back to the primary key of the row. This allows for fast lookups based on the contents of the JSON object, a feat not possible with traditional secondary indexes.</p>
</li>
<li>
<p><strong>CouchDB's Map Indexes on FoundationDB:</strong> The design for CouchDB's powerful <a href="https://raw.githubusercontent.com/apache/couchdb/refs/heads/main/src/docs/rfcs/008-map-indexes.md">map-based views on FoundationDB</a> provides another clear example. A user-defined <code>map</code> function processes each document to <code>emit</code> key-value pairs, which are then stored in FoundationDB to create a secondary index. This entire indexing subsystem is a layer built on top of FDB's core key-value capabilities.</p>
</li>
<li>
<p><strong>Azure DocumentDB's Schema-Agnostic Indexing:</strong> Before it was known as Cosmos DB, Microsoft's <a href="https://www.vldb.org/pvldb/vol8/p1668-shukla.pdf">Azure DocumentDB</a> was designed with a powerful indexing subsystem. It could automatically index all data within JSON documents without requiring developers to define a schema or configure secondary indexes. This allowed for real-time queries over schemaless data, a feature implemented by treating the index itself as data in the underlying storage engine.</p>
</li>
</ul>
<h3 id="multi-model-databases-cosmos-db-and-yugabytedb"><a class="header" href="#multi-model-databases-cosmos-db-and-yugabytedb">Multi-Model Databases: Cosmos DB and YugabyteDB</a></h3>
<p>Other databases use this pattern to support multiple data models on a single, unified backend.</p>
<ul>
<li>
<p><strong>Azure Cosmos DB:</strong> Microsoft's global-scale database projects multiple data models (Document, Graph, Key-Value) over a <a href="http://muratbuffalo.blogspot.com/2018/08/azure-cosmos-db.html">minimalist core data model</a>. The storage engine itself is agnostic to whether it's storing a document or a graph node.</p>
</li>
<li>
<p><strong>YugabyteDB:</strong> Follows a similar <a href="https://docs.yugabyte.com/latest/architecture/layered-architecture/">layered design</a>, with a query layer that supports both SQL and Cassandra APIs on top of <strong>DocDB</strong>, its underlying distributed document store, which itself functions as a key-value store.</p>
</li>
</ul>
<h2 id="the-unbundled-database-foundationdb"><a class="header" href="#the-unbundled-database-foundationdb">The Unbundled Database: FoundationDB</a></h2>
<p>All these examples point to a powerful conclusion: many modern databases are, internally, a specialized data model layer tightly bundled with a general-purpose key-value storage engine.</p>
<p>FoundationDB's philosophy is to <strong>unbundle</strong> these two layers. It provides <em>only</em> the core storage engine, but it makes that engine more powerful and generic than any of the bundled equivalents. It gives you:</p>
<ul>
<li>An ordered key-value store.</li>
<li>Strictly serializable ACID transactions.</li>
<li>Exceptional performance and proven reliability.</li>
</ul>
<p>This frees you, the developer, to build <em>any</em> data model layer you can imagine. You get the power of a world-class distributed storage engine without being locked into a specific, high-level data model. FoundationDB is the ultimate realization of the layered database architecture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-culture-of-correctness"><a class="header" href="#a-culture-of-correctness">A Culture of Correctness</a></h1>
<ul>
<li><a href="meet_fdb/correctness.html#the-foundation-flow">The Foundation: Flow</a></li>
<li><a href="meet_fdb/correctness.html#the-engine-deterministic-simulation">The Engine: Deterministic Simulation</a></li>
<li><a href="meet_fdb/correctness.html#the-fuel-generative-testing-and-buggify">The Fuel: Generative Testing and Buggify</a></li>
<li><a href="meet_fdb/correctness.html#the-result-confidence-at-scale">The Result: Confidence at Scale</a></li>
</ul>
<p>Distributed systems are notoriously difficult to build correctly. The number of possible states, race conditions, and failure modes is astronomical. While tools like <a href="http://jepsen.io/">Jepsen</a> have become an industry standard for validating the claims of distributed databases, FoundationDB's approach to correctness goes much deeper. It is built on a philosophy of <strong>simulation-driven development</strong> that is unmatched in the industry.</p>
<p>This chapter explores the layers of this testing strategy, which has allowed FoundationDB to achieve its legendary stability.</p>
<h2 id="the-foundation-flow"><a class="header" href="#the-foundation-flow">The Foundation: Flow</a></h2>
<p>The story of FoundationDB's correctness begins with its programming language: <strong>Flow</strong>. Developed in the first weeks of the project, Flow is a C++ extension that brings actor-based concurrency to the language. As the engineering team explains:</p>
<blockquote>
<p>We‚Äôd need efficient asynchronous communicating processes like in Erlang... but we‚Äôd also need the raw speed, I/O efficiency, and control of C++. To meet these challenges, we developed... Flow, a new programming language that brings actor-based concurrency to C++11.</p>
</blockquote>
<p>Flow isn't just a convenience; it's the critical enabler for the entire testing strategy. By controlling the scheduling of actors and abstracting away I/O, Flow makes it possible to run a deterministic simulation of an entire FoundationDB cluster in a single thread.</p>
<h2 id="the-engine-deterministic-simulation"><a class="header" href="#the-engine-deterministic-simulation">The Engine: Deterministic Simulation</a></h2>
<p>This leads to the crown jewel of the testing suite: the simulation framework. For the first 18 months of its development, FoundationDB never sent a single packet over a real network. It was built and tested entirely in simulation.</p>
<p>How does it work?</p>
<ul>
<li><strong>Single-Threaded Execution:</strong> The entire cluster‚Äîevery logical process, client, and server‚Äîruns as a set of actors within a single OS thread.</li>
<li><strong>Simulated Interfaces:</strong> All external communication, including network, disk, and time, is replaced with a deterministic, in-memory simulation. The network is not reliable; it can be partitioned, delayed, and reordered by the simulator.</li>
<li><strong>Perfect Reproducibility:</strong> Because the simulation is single-threaded and the inputs are controlled by a random seed, any test run is perfectly deterministic. If a test fails with a specific seed, a developer can reproduce the <em>exact</em> sequence of events that led to the failure, down to the scheduling of individual actors.</li>
</ul>
<p>This allows for a level of testing that is impossible with traditional methods. The team has run the equivalent of a <strong>trillion CPU-hours</strong> of simulated stress testing, exploring state spaces that would be impossible to cover in the real world.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/4fFDFbi3toc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="the-fuel-generative-testing-and-buggify"><a class="header" href="#the-fuel-generative-testing-and-buggify">The Fuel: Generative Testing and Buggify</a></h2>
<p>Deterministic simulation is necessary, but not sufficient. As one engineer put it:</p>
<blockquote>
<p>The reason why people write tests is because human beings are astonishingly bad at thinking through all the possible branches of control flow... that very fact means that we're unable to write tests to cover all the things that we actually need to cover.</p>
</blockquote>
<p>Instead of trying to write specific tests for every scenario, the FoundationDB team built a system for <strong>generating new and interesting tests</strong>. A test in FoundationDB is not a simple unit test; it's a combination of a <strong>workload</strong> (the goal) and a set of <strong>chaos agents</strong> (things trying to break the goal).</p>
<p>For example, a test might specify a workload of 5,000 transactions per second while simultaneously:</p>
<ul>
<li><strong>Clogging the network:</strong> Randomly stopping and reordering network packets.</li>
<li><strong>Killing machines:</strong> Randomly rebooting virtual servers.</li>
<li><strong>Changing the configuration:</strong> Forcing the cluster to re-elect its coordinators.</li>
</ul>
<p>To make this even more powerful, developers use a macro called <code>BUGGIFY</code>. This macro allows them to explicitly cooperate with the simulator by instrumenting the code with potential failure points. For example, a developer can wrap a piece of code in <code>BUGGIFY</code> to tell the simulator, "This is an interesting place to inject a 10-second delay, but only 1% of the time."</p>
<p>This allows the simulation to explore not just external failures (like network partitions) but also internal, heisenbug-like conditions in a controlled and deterministic way.</p>
<h2 id="the-result-confidence-at-scale"><a class="header" href="#the-result-confidence-at-scale">The Result: Confidence at Scale</a></h2>
<p>The implications of this approach are profound:</p>
<ul>
<li><strong>CI as a Brute-Force Weapon:</strong> Every pull request is subjected to hundreds of thousands of simulation tests, running on hundreds of cores for hours, before a human even begins a code review.</li>
<li><strong>Focus on Invention, Not Regression:</strong> Developers can focus on building new features, confident that the CI system will relentlessly probe their code for correctness against a chaotic world of failures.</li>
</ul>
<p>As the original team said, "It seems unlikely that we would have been able to build FoundationDB without this technology." It is this deep, foundational commitment to correctness that makes FoundationDB one of the most robust and trustworthy databases in the world.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<ul>
<li><a href="getting_started/installation.html#do-i-need-the-client-or-the-server">Do I Need the Client or the Server?</a>
<ul>
<li><a href="getting_started/installation.html#the-server-package">The Server Package</a></li>
<li><a href="getting_started/installation.html#the-client-package">The Client Package</a></li>
</ul>
</li>
<li><a href="getting_started/installation.html#the-cluster-file-your-key-to-the-cluster">The Cluster File: Your Key to the Cluster</a></li>
<li><a href="getting_started/installation.html#-a-critical-note-on-versioning">‚ö†Ô∏è A Critical Note on Versioning</a></li>
</ul>
<p>This chapter guides you through setting up FoundationDB. While the official documentation provides detailed, platform-specific instructions, this guide will help you understand the components and make the right choices for your setup.</p>
<ul>
<li><a href="https://apple.github.io/foundationdb/getting-started-linux.html">Official Docs: Getting Started on Linux</a></li>
<li><a href="https://apple.github.io/foundationdb/getting-started-mac.html">Official Docs: Getting Started on macOS</a></li>
</ul>
<h2 id="do-i-need-the-client-or-the-server"><a class="header" href="#do-i-need-the-client-or-the-server">Do I Need the Client or the Server?</a></h2>
<p>The first step is to decide which package you need from the <a href="https://apple.github.io/foundationdb/downloads.html">Downloads page</a>.</p>
<h3 id="the-server-package"><a class="header" href="#the-server-package">The Server Package</a></h3>
<p>Install the <strong>server</strong> package if you want to run a FoundationDB database cluster on a machine. This is for you if you are:</p>
<ul>
<li>Setting up a new development environment on your local machine.</li>
<li>Provisioning a server to be part of a production cluster.</li>
</ul>
<p>This package contains the core <code>fdbserver</code> binary, which runs the database, and <code>fdbmonitor</code>, which manages the server process.</p>
<h3 id="the-client-package"><a class="header" href="#the-client-package">The Client Package</a></h3>
<p>Install the <strong>client</strong> package if a machine only needs to connect to an <em>existing</em> FoundationDB cluster. This is for you if you are:</p>
<ul>
<li>Building an application that uses a FoundationDB binding (e.g., in Python, Go, or Java).</li>
<li>Using command-line tools like <code>fdbcli</code> to administer a remote cluster.</li>
</ul>
<p>This package provides the necessary C libraries (<code>libfdb_c.so</code>) that all language bindings depend on, as well as several administrative tools.</p>
<h2 id="the-cluster-file-your-key-to-the-cluster"><a class="header" href="#the-cluster-file-your-key-to-the-cluster">The Cluster File: Your Key to the Cluster</a></h2>
<p>Whether you install the client or the server, you will get a <strong>cluster file</strong> (e.g., <code>/etc/foundationdb/fdb.cluster</code>). This small text file is critically important:</p>
<blockquote>
<p>The cluster file contains the IP addresses and ports of the coordination servers. It's how any client or server finds and connects to the database.</p>
</blockquote>
<p>To connect to a cluster, your client machine must have a copy of that cluster's <code>fdb.cluster</code> file. When you set up a new server, one is created for you. When you set up a client to talk to an existing cluster, you must copy the file from the cluster to your client machine.</p>
<h2 id="-a-critical-note-on-versioning"><a class="header" href="#-a-critical-note-on-versioning">‚ö†Ô∏è A Critical Note on Versioning</a></h2>
<p>FoundationDB enforces strict compatibility between the client library and server processes. This is a common source of confusion for new users.</p>
<p><strong>The Rule:</strong> The installed client library (<code>libfdb_c</code>) and the server binaries (<code>fdbserver</code>) <strong>must</strong> have the same major and minor version numbers. For example, a client with version <code>7.1.x</code> can only talk to a server with version <code>7.1.y</code>. It <strong>cannot</strong> talk to a server running <code>7.2.z</code> or <code>6.3.w</code>.</p>
<p>However, you can connect to a cluster with an older version by specifying the API version in your client code. For example, if your client machine has the <code>7.4.x</code> libraries installed, you can still connect to a <code>7.3.z</code> cluster by calling <code>fdb.select_api_version(730)</code> before connecting. This mechanism is particularly useful for facilitating rolling upgrades, allowing clients to be upgraded before the servers.</p>
<p>If you mix incompatible versions without selecting a compatible API version, your application will likely fail to connect, often by hanging indefinitely. The server logs may show <code>ConnectionRejected</code> errors with the reason <code>IncompatibleProtocolVersion</code>. It's crucial to ensure your client machines and server cluster are running compatible versions, or that you are using <code>select_api_version</code> correctly during an upgrade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-on-foundationdb"><a class="header" href="#develop-on-foundationdb">Develop on FoundationDB</a></h1>
<p>This section provides a deeper look into the development of FoundationDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-design-tuples-subspaces-and-directories"><a class="header" href="#key-design-tuples-subspaces-and-directories">Key Design: Tuples, Subspaces, and Directories</a></h1>
<ul>
<li><a href="develop_layer/crafting-row-keys.html#the-challenge-hand-crafting-keys">The Challenge: Hand-Crafting Keys</a></li>
<li><a href="develop_layer/crafting-row-keys.html#layer-1-the-tuple">Layer 1: The <code>Tuple</code></a></li>
<li><a href="develop_layer/crafting-row-keys.html#layer-2-the-subspace">Layer 2: The <code>Subspace</code></a></li>
<li><a href="develop_layer/crafting-row-keys.html#layer-3-the-directory">Layer 3: The <code>Directory</code></a></li>
</ul>
<p>In a key-value store, the way you structure your keys is one of the most important architectural decisions you will make. Your key schema determines how your data is organized, how efficiently you can query it, and how well your workload will scale. This chapter introduces FoundationDB's powerful, layered abstractions for key management.</p>
<h2 id="the-challenge-hand-crafting-keys"><a class="header" href="#the-challenge-hand-crafting-keys">The Challenge: Hand-Crafting Keys</a></h2>
<p>At the lowest level, a key is just a sequence of bytes. In many key-value systems, developers are forced to manually craft these byte arrays, a process that is both tedious and error-prone.</p>
<p>Consider storing user data. You might decide on a key structure like <code>(user_id, attribute_name)</code>. To implement this, you would need to write code that serializes the <code>user_id</code> (an integer) and the <code>attribute_name</code> (a string) into a single byte array, taking care to handle different data types, lengths, and ordering correctly. This is brittle; a small change in the format can break your application.</p>
<p>FoundationDB provides a much better way.</p>
<h2 id="layer-1-the-tuple"><a class="header" href="#layer-1-the-tuple">Layer 1: The <code>Tuple</code></a></h2>
<p>The most fundamental building block for key design is the <strong>Tuple</strong>. A tuple is an ordered collection of elements of different types (like strings, integers, and UUIDs). The FoundationDB client libraries provide a <code>pack()</code> function that serializes a tuple into a byte string that correctly preserves type and ordering.</p>
<pre><code class="language-python">import fdb.tuple

# A tuple containing a string and an integer
user_profile_tuple = ('user', 12345)

# Pack the tuple into a byte key
key = fdb.tuple.pack(user_profile_tuple)

# The result is a byte string suitable for use as a key
# b'\x02user\x00\x1509'
print(repr(key))

# You can unpack the bytes back into the original tuple
unpacked_tuple = fdb.tuple.unpack(key)
assert unpacked_tuple == user_profile_tuple
</code></pre>
<p>This simple abstraction solves the manual serialization problem. You can think in terms of structured data, and the tuple layer handles the byte-level representation for you. Because the packing format is standardized across all language bindings, a key packed in Python can be unpacked in Go, Java, or any other language.</p>
<h2 id="layer-2-the-subspace"><a class="header" href="#layer-2-the-subspace">Layer 2: The <code>Subspace</code></a></h2>
<p>Building on tuples, the next layer of abstraction is the <strong>Subspace</strong>. A subspace is a way to create a dedicated namespace within the database for a particular category of data. It works by defining a prefix tuple that is automatically prepended to all keys packed within that subspace.</p>
<p>This is a powerful organizational tool. For example, you can create separate subspaces for user data, application settings, and logging events.</p>
<pre><code class="language-python">import fdb.tuple

# Create a subspace for storing user profiles
user_subspace = fdb.Subspace(('users',))

# Now, keys created within this subspace will be prefixed
# with the packed representation of ('users',)
key1 = user_subspace.pack(('alice',))
key2 = user_subspace.pack(('bob',))

# key1 is now b'\x02users\x00\x02alice\x00'
# key2 is now b'\x02users\x00\x02bob\x00'
print(repr(key1))
print(repr(key2))

# You can also use the subspace to unpack a key,
# which strips the prefix automatically.
unpacked = user_subspace.unpack(key1)
assert unpacked == ('alice',)
</code></pre>
<p>Subspaces allow you to isolate data and perform range scans over a specific category of information without worrying about colliding with other parts of your keyspace.</p>
<h2 id="layer-3-the-directory"><a class="header" href="#layer-3-the-directory">Layer 3: The <code>Directory</code></a></h2>
<p>The highest level of abstraction is the <strong>Directory</strong>. Directories are a tool for managing subspaces. While you can create subspaces with fixed prefixes (like <code>('users',)</code>), directories allow you to create and manage them dynamically.</p>
<blockquote>
<p>Directories are the recommended approach for organizing the keyspace of one or more applications.</p>
</blockquote>
<p>A directory allows you to associate a human-readable path (like <code>('users', 'profiles')</code>) with a short, randomly generated integer prefix. This has two major benefits:</p>
<ol>
<li><strong>Shorter Keys:</strong> The generated prefix is much shorter than the packed representation of the full path, saving space.</li>
<li><strong>Schema Management:</strong> You can list, move, and remove directories. Moving a directory is a fast metadata-only change; it doesn't require rewriting all the keys within it.</li>
</ol>
<pre><code class="language-python">import fdb
import fdb.directory

fdb.api_version(710)
db = fdb.open()

# Create or open a directory at a specific path
app_dir = fdb.directory.create_or_open(db, ('my-app',))

# Create subspaces within that directory
users_subspace = app_dir.create_or_open(db, ('users',))
logs_subspace = app_dir.create_or_open(db, ('logs',))

# The key for the 'users' subspace might be b'\x15\x01', a much
# shorter prefix than packing the full path.
print(repr(users_subspace.key()))

# You can now use this subspace as before
@fdb.transactional
def set_user(tr, name):
    tr[users_subspace.pack((name,))] = b'some_profile_data'

set_user(db, 'charlie')
</code></pre>
<p>By using these three layers‚ÄîTuples for serialization, Subspaces for namespacing, and Directories for management‚Äîyou can build sophisticated and maintainable data models on top of the simple key-value interface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practice-for-storing-structured-data"><a class="header" href="#best-practice-for-storing-structured-data">Best practice for storing structured data</a></h1>
<p>When storing structured data like JSON objects in FoundationDB, you have two primary approaches. Each has its own set of trade-offs.</p>
<h2 id="store-the-object-as-a-blob"><a class="header" href="#store-the-object-as-a-blob">Store the object as a blob</a></h2>
<p>If you decide to store the object as a single blob, you will need to pay the cost of reading the entire object back, even if you only need to access a single field. This approach can be efficient if you always read the entire document anyway (e.g., returning it as JSON via a REST API).</p>
<p>However, if you have a few fields that are updated frequently (like a <code>last_accessed_timestamp</code>), this option will incur a large serialization overhead. Furthermore, due to the value size limit in FDB, you may need to split a large object into multiple key-value pairs.</p>
<p>On the other hand, storing data as a single blob (or even more aggressively, batching multiple objects into one) provides an opportunity to compress the data on disk. FoundationDB does not provide built-in compression for key-value data, so this would need to be handled at the application layer.</p>
<h2 id="store-the-object-as-separate-key-value-pairs"><a class="header" href="#store-the-object-as-separate-key-value-pairs">Store the object as separate key-value pairs</a></h2>
<p>When an object is stored as separate key-value pairs, random access to a single field becomes much faster and more efficient. This approach makes implementing technologies like GraphQL more feasible.</p>
<p>For example, a JSON object like:</p>
<pre><code class="language-json">{
  "id": 123,
  "name": "John Doe",
  "email": "john.doe@example.com"
}
</code></pre>
<p>Could be stored as:</p>
<pre><code>(123, "name") = "John Doe"
(123, "email") = "john.doe@example.com"
</code></pre>
<p>However, this comes at a cost: increased disk space usage. There is little to no opportunity to compress the data on disk when using this method.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>If you‚Äôre building a generic document database, it‚Äôs challenging to pick one strategy that works best for all use cases. You might consider making the storage strategy configurable, or even adaptive based on the workload.</p>
<p>For example, the <a href="https://github.com/FoundationDB/fdb-document-layer">FDB Document Layer</a> allows data to be stored fully expanded or packed into 4k blocks.</p>
<p>To learn more about compressing data in this context, you can read the discussion in <a href="https://forums.foundationdb.org/t/best-practice-of-storing-structs-should-i-pack-or-store-fields-separately/425/5?u=dongxineric">this forum post</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-from-the-community-open-source-layers"><a class="header" href="#learning-from-the-community-open-source-layers">Learning from the Community: Open-Source Layers</a></h1>
<p>One of the best ways to learn how to build on FoundationDB is to study existing, production-proven layers. A "layer" is simply a library or service that provides a higher-level data model on top of FoundationDB's ordered key-value store. By examining how these layers map their data models to keys and values, you can gain invaluable insights for your own projects.</p>
<p>Here are some of the most prominent open-source layers developed by the FoundationDB community.</p>
<ul>
<li><a href="develop_layer/studiable-layers.html#the-record-layer">The Record Layer</a></li>
<li><a href="develop_layer/studiable-layers.html#the-document-layer">The Document Layer</a></li>
<li><a href="develop_layer/studiable-layers.html#the-zookeeper-layer">The ZooKeeper Layer</a></li>
<li><a href="develop_layer/studiable-layers.html#the-time-series-layer">The Time-Series Layer</a></li>
<li><a href="develop_layer/studiable-layers.html#warp-10">Warp 10</a></li>
</ul>
<h2 id="the-record-layer"><a class="header" href="#the-record-layer">The Record Layer</a></h2>
<p>The Record Layer provides a structured, record-oriented data store on top of FoundationDB, similar to a traditional relational database. It is used in production at Apple to power CloudKit.</p>
<ul>
<li><strong>GitHub Repo:</strong> <a href="https://github.com/foundationdb/fdb-record-layer">foundationdb/fdb-record-layer</a></li>
<li><strong>Academic Paper:</strong> <a href="https://www.foundationdb.org/files/record-layer-paper.pdf">FoundationDB Record Layer</a></li>
<li><strong>Key Videos:</strong>
<ul>
<li><a href="https://youtu.be/HLE8chgw6LI">FoundationDB Record Layer: Open Source Structured Storage on FoundationDB</a> (Nicholas Schiefer, Apple)</li>
<li><a href="https://youtu.be/SvoUHHM9IKU">Using FoundationDB and the FDB Record Layer to Build CloudKit</a> (Scott Gray, Apple)</li>
</ul>
</li>
</ul>
<h2 id="the-document-layer"><a class="header" href="#the-document-layer">The Document Layer</a></h2>
<p>The Document Layer implements a MongoDB¬Æ-compatible API, allowing you to store and query JSON documents within FoundationDB.</p>
<ul>
<li><strong>GitHub Repo:</strong> <a href="https://github.com/FoundationDB/fdb-document-layer">FoundationDB/fdb-document-layer</a></li>
<li><strong>Key Video:</strong>
<ul>
<li><a href="https://youtu.be/KPqmB13zI9c">FoundationDB Document Layer</a> (Bhaskar Muppana, Apple)</li>
</ul>
</li>
</ul>
<h2 id="the-zookeeper-layer"><a class="header" href="#the-zookeeper-layer">The ZooKeeper Layer</a></h2>
<p>This layer implements the Apache ZooKeeper API, providing a distributed coordination service built on FoundationDB.</p>
<ul>
<li><strong>GitHub Repo:</strong> <a href="https://github.com/pH14/fdb-zk">pH14/fdb-zk</a></li>
<li><strong>Key Video:</strong>
<ul>
<li><a href="https://youtu.be/3FYpf1QMPgQ">A ZooKeeper Layer for FoundationDB</a> (Paul Hemberger, HubSpot)</li>
</ul>
</li>
</ul>
<h2 id="the-time-series-layer"><a class="header" href="#the-time-series-layer">The Time-Series Layer</a></h2>
<p>This is an experimental, high-performance layer written in Go, designed specifically for storing and querying time-series data with high compression.</p>
<ul>
<li><strong>GitHub Repo:</strong> <a href="https://github.com/richardartoul/tsdb-layer">richardartoul/tsdb-layer</a></li>
<li><strong>Key Video:</strong>
<ul>
<li><a href="https://www.youtube.com/watch?v=W6yQ9Pwgb1A">Time Series and FoundationDB: Millions of Writes/s and 10x Compression in 2000 Lines of Go</a></li>
</ul>
</li>
</ul>
<h2 id="warp-10"><a class="header" href="#warp-10">Warp 10</a></h2>
<p>Warp 10 is a powerful platform for managing time-series data. While it was not originally built on FoundationDB, version 3.0 and later versions have adopted it to replace HBase. This change was motivated by a desire to simplify operations and eliminate the dependency on the Hadoop ecosystem.</p>
<ul>
<li><strong>GitHub Repo:</strong> <a href="https://github.com/senx/warp10-platform">senx/warp10-platform</a></li>
<li><strong>Key Blog Post:</strong> <a href="https://blog.senx.io/introducing-warp-10-3-0/">Introducing Warp 10 3.0!</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices-and-pitfalls"><a class="header" href="#best-practices-and-pitfalls">Best Practices and Pitfalls</a></h1>
<p>This chapter provides a collection of best practices, advanced techniques, and common pitfalls to help you build robust, production-ready layers on FoundationDB.</p>
<ul>
<li><a href="develop_layer/tips.html#transaction-management">Transaction Management</a>
<ul>
<li><a href="develop_layer/tips.html#use-timeouts-and-retry-limits">Use Timeouts and Retry Limits</a></li>
<li><a href="develop_layer/tips.html#set-transaction-priority">Set Transaction Priority</a></li>
</ul>
</li>
<li><a href="develop_layer/tips.html#observability">Observability</a>
<ul>
<li><a href="develop_layer/tips.html#tag-your-transactions">Tag Your Transactions</a></li>
<li><a href="develop_layer/tips.html#enable-client-trace-logs">Enable Client Trace Logs</a></li>
</ul>
</li>
<li><a href="develop_layer/tips.html#advanced-techniques">Advanced Techniques</a>
<ul>
<li><a href="develop_layer/tips.html#the-metadataversion-key">The <code>metadataVersion</code> Key</a></li>
<li><a href="develop_layer/tips.html#the-timekeeper">The <code>TimeKeeper</code></a></li>
<li><a href="develop_layer/tips.html#special-keys">Special Keys</a></li>
</ul>
</li>
<li><a href="develop_layer/tips.html#common-pitfalls-the-directory-layer">Common Pitfalls: The Directory Layer</a></li>
</ul>
<h2 id="transaction-management"><a class="header" href="#transaction-management">Transaction Management</a></h2>
<h3 id="use-timeouts-and-retry-limits"><a class="header" href="#use-timeouts-and-retry-limits">Use Timeouts and Retry Limits</a></h3>
<p>Most language bindings provide a <code>run</code> or <code>transact</code> method that automatically handles the retry loop for you. However, to prevent transactions from running indefinitely, it is critical to configure two options:</p>
<ul>
<li><strong>Timeout:</strong> Set a timeout in milliseconds. If the transaction takes longer than this to commit, it will be automatically cancelled. This is a crucial backstop for preventing stuck application threads.</li>
<li><strong>Retry Limit:</strong> Set a maximum number of retries. This prevents a transaction from retrying endlessly in the case of a persistent conflict or a live-lock scenario.</li>
</ul>
<p>These options should be set on every transaction to ensure your application remains stable under load.</p>
<h3 id="set-transaction-priority"><a class="header" href="#set-transaction-priority">Set Transaction Priority</a></h3>
<p>FoundationDB supports transaction priorities to help manage workloads.</p>
<ul>
<li><strong>Default:</strong> The standard priority for most latency-sensitive, user-facing operations.</li>
<li><strong>Batch:</strong> A lower priority for background work, such as data cleanup or analytics. Batch priority transactions will yield to default priority transactions, ensuring that they don't interfere with your main application workload.</li>
<li><strong>System Immediate:</strong> The highest priority, which can block other transactions. Its use is discouraged outside of low-level administrative tools.</li>
</ul>
<h2 id="observability"><a class="header" href="#observability">Observability</a></h2>
<h3 id="tag-your-transactions"><a class="header" href="#tag-your-transactions">Tag Your Transactions</a></h3>
<p>FoundationDB allows you to add a byte-string <strong>tag</strong> to any transaction. This is an invaluable tool for observability and performance management. You can use tags to identify different types of workloads (e.g., <code>user_signup</code>, <code>post_comment</code>). The <code>fdbcli</code> tool can then be used to monitor the rate of transactions with specific tags and even throttle them if they are causing excessive load.</p>
<p>See the official documentation on <a href="https://apple.github.io/foundationdb/transaction-tagging.html">Transaction Tagging</a> for more details.</p>
<h3 id="enable-client-trace-logs"><a class="header" href="#enable-client-trace-logs">Enable Client Trace Logs</a></h3>
<p>By default, clients do not generate detailed trace logs. To debug performance issues, you can enable them by setting the <code>TraceEnable</code> database option. You can then add a <code>DebugTransactionIdentifier</code> to a specific transaction and set the <code>LogTransaction</code> option to get detailed, low-level logs about its execution, including all keys and values read and written.</p>
<h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<h3 id="the-metadataversion-key"><a class="header" href="#the-metadataversion-key">The <code>metadataVersion</code> Key</a></h3>
<p>The special key <code>\xFF/metadataVersion</code> is a cluster-wide version counter that can be used to implement client-side caching. Its value is sent to clients with every read version, so reading it does not require a round-trip to a storage server. A layer can watch this key to know when to invalidate a local cache.</p>
<p><strong>Note:</strong> If you write to the <code>metadataVersion</code> key, you cannot read it again in the same transaction.</p>
<h3 id="the-timekeeper"><a class="header" href="#the-timekeeper">The <code>TimeKeeper</code></a></h3>
<p>The <code>Cluster Controller</code> maintains a map of recent read versions to wall-clock times. This can be accessed by scanning the key range beginning with <code>\xFF\x02/timeKeeper/map/</code>. This can be useful for approximating a global clock.</p>
<h3 id="special-keys"><a class="header" href="#special-keys">Special Keys</a></h3>
<p>Keys prefixed with <code>\xFF\xFF</code> are ‚Äúspecial‚Äù keys that are materialized on-demand when read. The most common example is <code>\xFF\xFF/status/json</code>, which returns a JSON document containing the cluster's status.</p>
<p>See the official documentation on <a href="https://apple.github.io/foundationdb/special-keys.html">Special Keys</a> for more details.</p>
<h2 id="common-pitfalls-the-directory-layer"><a class="header" href="#common-pitfalls-the-directory-layer">Common Pitfalls: The Directory Layer</a></h2>
<p>The Directory Layer is a powerful tool, but it has several sharp edges that developers must be aware of:</p>
<ul>
<li><strong>Concurrent Mutations:</strong> Modifying the same directory (e.g., creating two different subdirectories within it) in multiple, concurrent transactions is not safe and can lead to corruption.</li>
<li><strong>Metadata Hotspots:</strong> Opening a directory with a long path requires one read per path element for every transaction. This can create a hotspot on the directory's internal metadata subspace.</li>
<li><strong>Multi-Cluster Deployments:</strong> The directory prefix allocator is not safe for multi-cluster deployments and can allocate the same prefix in different clusters, leading to data corruption if the data is ever merged.</li>
<li><strong>Redwood and Prefix Compression:</strong> The Redwood storage engine (new in 7.0) provides native key-prefix compression. This offers many of the same space-saving benefits as the Directory Layer without the associated complexity and caveats. For new projects, especially those using Redwood, consider whether you can use subspaces with descriptive prefixes directly instead of relying on the Directory Layer.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operate-foundationdb"><a class="header" href="#operate-foundationdb">Operate FoundationDB</a></h1>
<p>This section provides a deeper look into the operation of FoundationDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-cluster-roles"><a class="header" href="#anatomy-of-a-cluster-roles">Anatomy of a Cluster: Roles</a></h1>
<ul>
<li><a href="operate_fdb/roles.html#the-coordinator">The Coordinator</a></li>
<li><a href="operate_fdb/roles.html#the-cluster-controller">The Cluster Controller</a></li>
<li><a href="operate_fdb/roles.html#the-proxies">The Proxies</a>
<ul>
<li><a href="operate_fdb/roles.html#the-grv-proxy">The GRV Proxy</a></li>
<li><a href="operate_fdb/roles.html#the-commit-proxy">The Commit Proxy</a></li>
</ul>
</li>
<li><a href="operate_fdb/roles.html#the-resolver">The Resolver</a></li>
<li><a href="operate_fdb/roles.html#the-log-server">The Log Server</a></li>
<li><a href="operate_fdb/roles.html#the-storage-server">The Storage Server</a></li>
<li><a href="operate_fdb/roles.html#the-data-distributor">The Data Distributor</a></li>
</ul>
<p>FoundationDB's architecture is built on a collection of specialized, stateless roles. This separation of concerns is a key reason for its high performance, scalability, and fault tolerance. A running <code>fdbserver</code> process can dynamically take on any of these roles as needed. Understanding them is the first step to understanding how FoundationDB works.</p>
<p>Here are the core roles in a FoundationDB cluster:</p>
<h2 id="the-coordinator"><a class="header" href="#the-coordinator">The Coordinator</a></h2>
<p>The <strong>Coordinator</strong> is the first process that any client or server connects to when joining the cluster. Its primary job is to manage the <em>cluster file</em>, a small, durable text file that contains the IP addresses and ports of the coordinators themselves. The coordinators elect a <strong>Cluster Controller</strong>, which serves as the singleton brain of the cluster.</p>
<h2 id="the-cluster-controller"><a class="header" href="#the-cluster-controller">The Cluster Controller</a></h2>
<p>The <strong>Cluster Controller</strong> is the authoritative monitor for the entire cluster. There is only one active Cluster Controller at any time. It is responsible for:</p>
<ul>
<li>Monitoring the health of all other <code>fdbserver</code> processes.</li>
<li>Recruiting new processes to take on roles as needed (e.g., if a Log Server fails).</li>
<li>Orchestrating recovery when a process fails.</li>
</ul>
<h2 id="the-proxies"><a class="header" href="#the-proxies">The Proxies</a></h2>
<p>FoundationDB splits the traditional role of a proxy into two distinct components: the <strong>GRV Proxy</strong> and the <strong>Commit Proxy</strong>. This separation allows for better scaling and specialization. Clients first interact with a GRV proxy to start a transaction and then with a Commit Proxy to commit it.</p>
<h3 id="the-grv-proxy"><a class="header" href="#the-grv-proxy">The GRV Proxy</a></h3>
<p>The <strong>GRV Proxy</strong> (Get Read Version Proxy) is responsible for one critical task: providing a <strong>Read Version</strong> to a client when it begins a transaction. To do this, the GRV proxy communicates with the Master to get the latest committed version from the transaction system. This ensures that the transaction gets a consistent snapshot view of the database. The <code>Ratekeeper</code> process can apply backpressure by slowing down the rate at which GRV Proxies issue read versions, which helps manage cluster load.</p>
<h3 id="the-commit-proxy"><a class="header" href="#the-commit-proxy">The Commit Proxy</a></h3>
<p>The <strong>Commit Proxy</strong> is the front door for all transaction <em>commits</em>. When a client commits a transaction, it sends its read and write sets to a Commit Proxy. The Commit Proxy orchestrates the second half of the transaction lifecycle:</p>
<ol>
<li>Getting a <strong>Commit Version</strong> from the Master.</li>
<li>Sending the transaction's read and write sets to the <strong>Resolver</strong> to check for conflicts.</li>
<li>If the transaction is valid, sending its mutations to the <strong>Log Servers</strong> to be made durable.</li>
<li>Reporting the final commit status back to the client.</li>
</ol>
<p>Because both proxy types are stateless, you can add more of them to the cluster to increase both the number of transactions that can be started and the overall commit throughput.</p>
<h2 id="the-resolver"><a class="header" href="#the-resolver">The Resolver</a></h2>
<p>The <strong>Resolver</strong> is the component that enforces serializability. During the commit process, the Commit Proxy sends the transaction's read and write sets to the Resolver. The Resolver checks if any of the keys in the read set have been modified by another transaction that has committed since the current transaction's read version was assigned. If a conflict is found, the transaction is rejected, and the client must retry.</p>
<h2 id="the-log-server"><a class="header" href="#the-log-server">The Log Server</a></h2>
<p>The <strong>Log Server</strong> is the heart of FoundationDB's durability guarantee. It implements the transaction log. When a transaction is ready to be committed, its mutations are sent to the Log Servers, which write them to durable storage (typically an SSD) before the commit is acknowledged to the client. The Log Servers do not need to apply the changes to the main data store; they just need to record them.</p>
<h2 id="the-storage-server"><a class="header" href="#the-storage-server">The Storage Server</a></h2>
<p>The <strong>Storage Server</strong> is responsible for storing the data. Each Storage Server holds a set of key ranges (shards). It serves read requests from clients and receives committed mutations from the Log Servers, applying them to its in-memory B-tree and eventually writing them to disk. Storage Servers are the workhorses of the cluster, and you can add more of them to increase both storage capacity and I/O performance.</p>
<h2 id="the-data-distributor"><a class="header" href="#the-data-distributor">The Data Distributor</a></h2>
<p>The <strong>Data Distributor</strong> is a background role responsible for ensuring that data is evenly distributed and replicated across all of the Storage Servers. It monitors the size and workload of each shard and will automatically move data between servers to prevent hotspots and ensure fault tolerance. It is also responsible for initiating data replication and healing the cluster after a Storage Server fails.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guidelines-for-choosing-coordinators"><a class="header" href="#guidelines-for-choosing-coordinators">Guidelines for Choosing Coordinators</a></h1>
<p>Unlike most roles in the cluster, which are assigned dynamically, coordinators must be configured statically. This requires careful consideration to ensure your cluster is both fault-tolerant and performant.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Coordinators are responsible for three critical functions:</p>
<ol>
<li><strong>Electing the Cluster Controller:</strong> The cluster controller is the leader of the cluster. This election is an iterative process, and having too many coordinators can increase the probability of failure in each round, slowing down the election process significantly.</li>
<li><strong>Storing Global State:</strong> During a recovery, this state is read, locked, and rewritten to all coordinators. The more coordinators you have, the longer this process takes, which can increase your recovery times.</li>
<li><strong>Facilitating Client Connections:</strong> Clients discover the cluster controller through the coordinators. While this path is optimized, in the worst case, a client may need to communicate with all coordinators, making new connections slower.</li>
</ol>
<p>Losing a majority of your coordinators will cause the database to become unavailable. However, having more coordinators than necessary can harm performance and make operations more complex.</p>
<h2 id="recommended-coordinator-counts"><a class="header" href="#recommended-coordinator-counts">Recommended Coordinator Counts</a></h2>
<p>The goal is to have enough coordinators to meet your fault-tolerance goals without adding unnecessary overhead.</p>
<ul>
<li>
<p><strong>Single Data Center:</strong> For a single-DC configuration with a replication factor of <code>R</code>, the recommended number of coordinators is <code>2*R - 1</code>. This configuration can tolerate the failure of <code>R-1</code> coordinators while still maintaining a majority.</p>
</li>
<li>
<p><strong>Multi-Data Center:</strong> For multi-DC deployments, you typically want to be resilient to the loss of at least one data center plus one additional machine failure. For these scenarios, we recommend <strong>9 coordinators</strong>, spread evenly across at least 3 DCs. This ensures that no single DC has more than 3 coordinators. If you lose one DC and one additional machine, you would lose at most 4 of your 9 coordinators, leaving a majority available.</p>
</li>
<li>
<p><strong>Two Data Centers:</strong> If you are only storing data in two DCs, we recommend provisioning 3 processes in a third data center to serve exclusively as coordinators.</p>
</li>
</ul>
<h2 id="determining-which-processes-to-use"><a class="header" href="#determining-which-processes-to-use">Determining Which Processes to Use</a></h2>
<p>When selecting which <code>fdbserver</code> processes will act as coordinators, follow two rules:</p>
<ol>
<li><strong>Unique Fault Domains:</strong> Every coordinator should be on a different physical machine or fault domain (and thus have a different <code>zoneid</code>).</li>
<li><strong>Even Distribution:</strong> Coordinators should be spread as evenly as possible across data centers and racks.</li>
</ol>
<p>Following these guidelines will help ensure your cluster achieves its desired level of fault tolerance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-foundationdb"><a class="header" href="#upgrading-foundationdb">Upgrading FoundationDB</a></h1>
<p>Upgrading a FoundationDB cluster can be a challenging process, but with the right procedure, it can be accomplished with zero downtime.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The main challenge is that the internal wire protocol used for communication between server processes is not guaranteed to be stable across different minor versions. This means that during a minor version upgrade (e.g., from 6.1 to 6.2), all <code>fdbserver</code> processes must be restarted with the new binaries simultaneously.</p>
<p>Clients must also use a protocol-compatible library to connect. To avoid client outages, FoundationDB supports a multi-version client feature, allowing an application to load both old and new client libraries at the same time.</p>
<p>This guide outlines a safe, zero-downtime upgrade process, assuming you are running <code>fdbserver</code> through <code>fdbmonitor</code>.</p>
<h2 id="server-upgrade-process"><a class="header" href="#server-upgrade-process">Server Upgrade Process</a></h2>
<p>The high-level process is as follows:</p>
<ol>
<li>
<p><strong>Install New Binaries:</strong> Install the new <code>fdbserver</code> binaries alongside the old ones. It's a good practice to place them in versioned directories, for example:</p>
<ul>
<li>Old: <code>/usr/bin/fdb/6.1.12/fdbserver</code></li>
<li>New: <code>/usr/bin/fdb/6.2.8/fdbserver</code></li>
</ul>
</li>
<li>
<p><strong>Update Monitor Configuration:</strong> Update the <code>fdbmonitor.conf</code> file to point to the new <code>fdbserver</code> binary path.</p>
</li>
<li>
<p><strong>Restart the Cluster:</strong> Using the <strong>old</strong> version of <code>fdbcli</code>, issue a coordinated restart of the cluster:</p>
<pre><code class="language-bash">fdbcli --exec 'kill; kill all; status'
</code></pre>
</li>
<li>
<p><strong>Verify Health:</strong> Using the <strong>new</strong> version of <code>fdbcli</code>, connect to the database and confirm that the cluster is healthy and running the new version.</p>
</li>
</ol>
<p>To minimize the risk of processes restarting organically with the new binary before the coordinated <code>kill</code>, you should set <code>kill_on_configuration_change=false</code> in your <code>fdbmonitor.conf</code> and minimize the time between steps 2 and 3.</p>
<h2 id="client-upgrade-process"><a class="header" href="#client-upgrade-process">Client Upgrade Process</a></h2>
<p>To ensure clients remain connected during the server upgrade, you must prepare them ahead of time using the multi-version client feature.</p>
<ol>
<li>
<p><strong>Install New Client Library:</strong> Install the new client library (<code>.so</code> or <code>.dylib</code>) into a dedicated directory. The filename should include the version (e.g., <code>/var/lib/fdb-multiversion/libfdbc_6.2.8.so</code>).</p>
</li>
<li>
<p><strong>Configure Environment Variable:</strong> Set the <code>FDB_NETWORK_OPTION_EXTERNAL_CLIENT_DIRECTORY</code> environment variable in your client application's environment to point to this directory (e.g., <code>/var/lib/fdb-multiversion</code>).</p>
</li>
<li>
<p><strong>Restart Client Application:</strong> Bounce your client application to make it load the new library in addition to the one it's already using.</p>
</li>
<li>
<p><strong>Verify Client Compatibility:</strong> Before upgrading the servers, you can check the database status JSON (<code>status json</code>) to confirm that all clients have loaded a compatible protocol version. The <code>cluster.clients.supported_versions</code> field will list all protocol versions supported by connected clients.</p>
</li>
<li>
<p><strong>Perform Server Upgrade:</strong> Once all clients are ready, proceed with the server upgrade steps described above.</p>
</li>
<li>
<p><strong>Clean Up:</strong> After the server upgrade is complete and stable, you can update your client applications to use the new library as their primary version and remove the old library files from the multi-version directory.</p>
</li>
</ol>
<h2 id="upgrading-other-binaries"><a class="header" href="#upgrading-other-binaries">Upgrading Other Binaries</a></h2>
<p>Tools like <code>fdbbackup</code> and <code>fdbdr</code> must also be protocol-compatible. You should upgrade these binaries after the main cluster upgrade is complete. There will be a temporary lag in backup and disaster recovery operations until these components are also running the new version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-distribution-and-movement"><a class="header" href="#data-distribution-and-movement">Data Distribution and Movement</a></h1>
<p>FoundationDB automatically manages the distribution of data across the cluster. This process is crucial for ensuring fault tolerance, balancing load, and managing storage space efficiently.</p>
<h2 id="reasons-for-data-movement"><a class="header" href="#reasons-for-data-movement">Reasons for Data Movement</a></h2>
<p>FoundationDB will only move data for a few specific reasons:</p>
<ul>
<li><strong>To restore replication after a failure:</strong> If a storage server fails, the data it was responsible for becomes under-replicated. The data distribution system will create new copies of that data on other servers to restore the desired replication level.</li>
<li><strong>To manage shard size:</strong> The system aims to keep data shards within an optimal size range (roughly 125MB to 500MB). It will split shards that grow too large and merge shards that become too small.</li>
<li><strong>To handle write hotspots:</strong> If a particular shard experiences a high volume of writes, it may be split to distribute the write load.</li>
<li><strong>To balance storage load:</strong> The system will move data to ensure that the total bytes stored are balanced evenly across all storage servers in the cluster.</li>
</ul>
<p>Notably, data distribution <strong>does not</strong> balance the load based on high read traffic. When moving a shard, it only considers the total bytes stored, not the read or write traffic on that shard. This means it's possible for multiple high-traffic ranges to be assigned to the same storage server.</p>
<h2 id="observing-data-movement"><a class="header" href="#observing-data-movement">Observing Data Movement</a></h2>
<p>You can monitor data movement activity through the <code>fdbcli</code> status command. The output provides key metrics:</p>
<pre><code>Data:
  Replication health   - Healthy
  Moving data          - 0.043 GB
  Sum of key-value sizes - 88 MB
  Disk space used      - 382 MB
</code></pre>
<p>The <code>Moving data</code> field shows how much data is currently in flight. There is no ETA published for data movement, and it's normal for it to be happening constantly, especially in a cluster with a high write workload.</p>
<h2 id="adjusting-distribution-speeds"><a class="header" href="#adjusting-distribution-speeds">Adjusting Distribution Speeds</a></h2>
<p>There are no simple controls for adjusting the speed of data distribution. While some configuration knobs exist (e.g., <code>DD_MOVE_KEYS_PARALLELISM</code>, <code>MOVE_KEYS_KRM_LIMIT</code>), changing them is strongly discouraged unless you have a specific need and understand the potential consequences. These settings must be applied at the startup of your <code>fdbserver</code> processes and should be handled with extreme caution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-record-layer-1"><a class="header" href="#the-record-layer-1">The Record Layer</a></h1>
<p>This section provides a deeper look into the Record Layer of FoundationDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-the-record-layer"><a class="header" href="#what-is-the-record-layer">What is the Record Layer?</a></h1>
<p>The FoundationDB Record Layer is an open-source library that provides a record-oriented data store with semantics similar to a relational database, implemented on top of FoundationDB. Think of it as a "middle layer" that provides common database-like features, making it easier to build complex, scalable applications on FDB.</p>
<p>It was created to solve the common and difficult challenges that arise when building a structured data layer on top of a key-value store, such as schema management, indexing, and query execution, especially in a multi-tenant environment.</p>
<h2 id="core-design-principles"><a class="header" href="#core-design-principles">Core Design Principles</a></h2>
<p>The Record Layer is built around a few core principles:</p>
<ul>
<li>
<p><strong>Structured, Schematized Data</strong>: It stores structured records using Google's <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a>. This provides a robust way to define a schema and evolve it over time.</p>
</li>
<li>
<p><strong>Stateless Architecture</strong>: The layer itself is completely stateless. All state is stored in FoundationDB or returned to the client (e.g., as a <code>continuation</code>). This simplifies scaling and operation, as any server can handle any request.</p>
</li>
<li>
<p><strong>Streaming Queries</strong>: The Record Layer is designed for a streaming model. For example, it only supports ordered queries (like SQL's <code>ORDER BY</code>) if there is an index that can produce the data in the requested order. This avoids large, stateful in-memory operations and makes performance predictable, favoring fast OLTP workloads over analytical OLAP queries.</p>
</li>
<li>
<p><strong>Extensibility</strong>: The layer is highly extensible. Clients can define their own custom index types, index maintainers, and query planner rules, allowing them to tailor the database's behavior to their specific needs.</p>
</li>
</ul>
<h2 id="the-record-store-a-logical-database"><a class="header" href="#the-record-store-a-logical-database">The "Record Store": A Logical Database</a></h2>
<p>A key abstraction in the Record Layer is the <strong>Record Store</strong>. A Record Store is a logical, self-contained database that holds all of a tenant's records, indexes, and metadata. This entire logical database is stored within a single, contiguous key-space in FoundationDB, called a <strong>subspace</strong>.</p>
<p>This design is a perfect fit for multi-tenant applications. For example, Apple's CloudKit uses this model to provide a distinct logical database for every application on every user's device‚Äîbillions of independent databases in total. Because a Record Store is just a range of keys, it can be easily moved between FDB clusters for load balancing.</p>
<h2 id="key-technical-features"><a class="header" href="#key-technical-features">Key Technical Features</a></h2>
<p>The Record Layer abstracts away several complex engineering problems by leveraging FoundationDB's core features.</p>
<h3 id="key-expressions-for-flexible-indexing"><a class="header" href="#key-expressions-for-flexible-indexing">Key Expressions for Flexible Indexing</a></h3>
<p>Indexes are defined using <strong>key expressions</strong>, which are functions that specify how to extract data from a record to form an index key. Key expressions can be simple (e.g., a single field's value) or complex. They can:</p>
<ul>
<li><strong>Concatenate</strong> multiple fields together.</li>
<li><strong>Fan out</strong> by creating multiple index entries from a single record, such as indexing each element in a repeated field (a list).</li>
<li><strong>Nest</strong> to index fields within a sub-record.</li>
</ul>
<p>This provides a powerful and flexible way to create indexes on highly structured, nested data.</p>
<h3 id="online-index-building"><a class="header" href="#online-index-building">Online Index Building</a></h3>
<p>Building an index on a large, live dataset is a hard problem. The Record Layer's online indexer handles this gracefully. When a new index is added, it transitions through several states:</p>
<ol>
<li><strong>Write-only</strong>: The index is maintained for all new and updated records, but it cannot yet be used for queries.</li>
<li><strong>Building</strong>: A background process scans all existing records in batches, adding their corresponding entries to the index. This process is transactional, fault-tolerant, and resumable.</li>
<li><strong>Readable</strong>: Once the background build is complete, the index is marked as readable and can be used by the query planner.</li>
</ol>
<h3 id="advanced-index-types"><a class="header" href="#advanced-index-types">Advanced Index Types</a></h3>
<p>The Record Layer includes several powerful, built-in index types:</p>
<ul>
<li><strong>VALUE</strong>: A standard index that maps the value from a key expression to the record's primary key.</li>
<li><strong>ATOMIC</strong>: An index that uses FoundationDB's atomic mutations to maintain aggregate statistics without transaction conflicts. This is used for <code>SUM</code>, <code>COUNT</code>, <code>MAX</code>, and <code>MIN</code> indexes.</li>
<li><strong>VERSION</strong>: An index on the commit version of a record. This creates a conflict-free, totally-ordered change log, which is ideal for synchronization. The version is a unique 12-byte value: 10 bytes from the FDB commit version and 2 bytes from a transaction-local counter in the Record Layer.</li>
<li><strong>RANK</strong>: An index that can answer questions like, "what is the Nth record in a given order?" or "what is the rank of this specific record?"</li>
<li><strong>TEXT</strong>: A full-text index for searching for words or phrases within a text field.</li>
</ul>
<h3 id="query-continuations-for-resource-control"><a class="header" href="#query-continuations-for-resource-control">Query Continuations for Resource Control</a></h3>
<p>To prevent any single request from consuming too many resources, all long-running operations are pausable. When a query hits a predefined limit (e.g., number of records scanned or time elapsed), it stops and returns the results it has found so far, along with an opaque <strong>continuation</strong>.</p>
<p>This continuation captures the exact state of the query. The client can pass it back in a new request to resume the query exactly where it left off. This makes the system highly scalable and resilient, as it allows for fine-grained control over resource usage.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><strong>Paper</strong>: <a href="https://www.foundationdb.org/files/record-layer-paper.pdf">FoundationDB Record Layer: A Multi-Tenant Structured Datastore</a> (SIGMOD '19)</li>
<li><strong>Video</strong>: <a href="https://www.youtube.com/watch?v=SvoUHHM9IKU">FoundationDB Record Layer: Open Source Structured Storage on FoundationDB</a> (FDB Summit 2018)</li>
<li><strong>Video</strong>: <a href="https://www.youtube.com/watch?v=HLE8chgw6LI">Using FoundationDB and the FDB Record Layer to Build CloudKit</a> (FDB Summit 2018)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-a-queuing-system-in-cloudkit"><a class="header" href="#quick-a-queuing-system-in-cloudkit">QuiCK: A Queuing System in CloudKit</a></h1>
<p>QuiCK is a distributed, transactional queuing system developed for and integrated into Apple's CloudKit. It is built on top of FoundationDB and the Record Layer. Its primary purpose is to reliably manage deferred, asynchronous tasks that are generated by CloudKit operations, such as updating search indexes, sending push notifications, or performing data compaction.</p>
<h2 id="the-challenge-queuing-at-cloudkit-scale"><a class="header" href="#the-challenge-queuing-at-cloudkit-scale">The Challenge: Queuing at CloudKit Scale</a></h2>
<p>CloudKit needed a way to manage a massive volume of asynchronous tasks without using a separate, external queuing system. Using an external system like Kafka or RabbitMQ presented several major challenges:</p>
<ol>
<li>
<p><strong>No Transactionality</strong>: It's impossible to have a single atomic transaction that spans both CloudKit's database (FDB) and an external queue. For example, if a user shares a Keynote document, the system must both update access permissions in the database and enqueue a task to send a push notification. Without a transactional queue, the database update could succeed while the task enqueue fails, leaving collaborators unaware of the share.</p>
</li>
<li>
<p><strong>Data Migration</strong>: CloudKit frequently moves user data between FDB clusters for load balancing. If a user's tasks were in a separate system, this would create a coordination nightmare. For example, if a user deletes a folder in iCloud Drive and their database is then moved to a new datacenter, their queued deletion task could be left behind, unable to find the data it's supposed to act on.</p>
</li>
<li>
<p><strong>Tenancy Mismatch</strong>: CloudKit has a fine-grained tenancy model with billions of logical databases (one for each user of each app). Traditional queuing systems are designed for thousands of topics, not billions. Mapping the CloudKit model to a traditional queue would be impossible.</p>
</li>
<li>
<p><strong>Operational Complexity</strong>: An external system would be another massive, stateful service to provision, monitor, and operate alongside the hundreds of FDB clusters that power CloudKit.</p>
</li>
</ol>
<p>To solve these issues, the team built QuiCK directly into CloudKit, storing queued tasks right alongside the user data they pertain to.</p>
<h2 id="core-design-and-technical-features"><a class="header" href="#core-design-and-technical-features">Core Design and Technical Features</a></h2>
<p>QuiCK's design overcomes the traditional concerns of building a queue on a database (like hotspots and consumer contention) through several key innovations.</p>
<h3 id="two-level-sharding"><a class="header" href="#two-level-sharding">Two-Level Sharding</a></h3>
<p>QuiCK avoids hotspots by sharding at an extreme scale:</p>
<ul>
<li>
<p><strong>Level 1: Queue Zones</strong>: The primary level of sharding consists of tens of billions of individual queues, called <strong>Queue Zones</strong>. Each tenant (a user of a CloudKit app) gets their own queue within their logical database. This means one tenant's activity can never create a hotspot that affects another.</p>
</li>
<li>
<p><strong>Level 2: Cluster Queues</strong>: To help consumers find work efficiently, a second, higher-level queue exists on each FDB cluster. When a task is first enqueued into a tenant's previously empty Queue Zone, the same transaction also adds a <strong>pointer</strong> to that zone into the higher-level Cluster Queue. Consumers poll the Cluster Queue to find these pointers, which efficiently leads them to tenants with work to be done.</p>
</li>
</ul>
<h3 id="fault-tolerant-leases-via-vesting-time"><a class="header" href="#fault-tolerant-leases-via-vesting-time">Fault-Tolerant Leases via Vesting Time</a></h3>
<p>To prevent multiple consumers from processing the same item, QuiCK uses a clever, fault-tolerant leasing mechanism. Instead of locking or immediately deleting an item, a consumer takes a lease by updating the item's <strong>vesting time</strong> to some point in the future (e.g., 5 minutes from now). This makes the item invisible to other consumers for the duration of the lease. If the consumer processes the item successfully, it deletes it. If the consumer crashes, the lease simply expires, and the item automatically becomes visible again for another consumer to pick up.</p>
<h3 id="polling-for-fairness-and-efficiency"><a class="header" href="#polling-for-fairness-and-efficiency">Polling for Fairness and Efficiency</a></h3>
<p>Given the massive number of queues, a push-based model is not feasible. Instead, QuiCK uses a polling-based model where a shared pool of consumers asks for work when they have capacity. This allows QuiCK to implement scheduling and fairness policies, deciding which queue to service next based on tenant priority or resource usage, preventing a single user from starving others.</p>
<h3 id="leveraging-foundationdb-and-the-record-layer"><a class="header" href="#leveraging-foundationdb-and-the-record-layer">Leveraging FoundationDB and the Record Layer</a></h3>
<p>QuiCK is a powerful example of building a complex subsystem on top of the FDB/Record Layer stack:</p>
<ul>
<li><strong>Transactional Integrity</strong>: Enqueuing a task and adding a pointer to the cluster queue are atomic operations within a standard FDB transaction.</li>
<li><strong>Exactly-Once Semantics</strong>: For tasks that only modify the database (no external side effects), QuiCK can achieve exactly-once semantics by processing the task and deleting it from the queue within a single transaction.</li>
<li><strong>Indexed Queues</strong>: The Record Layer's secondary indexes are used to order items within a Queue Zone by priority and vesting time, so consumers always process the most important item first.</li>
</ul>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><strong>Paper</strong>: <a href="https://www.foundationdb.org/files/QuiCK.pdf">QuiCK: A Queuing System in CloudKit</a> (SIGMOD '21)</li>
<li><strong>Video</strong>: <a href="https://www.youtube.com/watch?v=I9mNENkZT90">QuiCK: A Queuing System in CloudKit</a> (SIGMOD '21)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundationdb-internals"><a class="header" href="#foundationdb-internals">FoundationDB Internals</a></h1>
<p>This section provides a deeper look into the internal architecture and components of FoundationDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-write-path"><a class="header" href="#the-write-path">The Write Path</a></h1>
<ul>
<li><a href="internals/the-write-path.html#the-steps-of-a-commit">The Steps of a Commit</a></li>
<li><a href="internals/the-write-path.html#the-final-step-data-storage">The Final Step: Data Storage</a></li>
</ul>
<p>Understanding the life of a write transaction is key to understanding how FoundationDB provides its powerful guarantees of strict serializability and durability. The process involves a carefully choreographed dance between several cluster roles.</p>
<p>Let's walk through the journey of a transaction from the moment a client calls <code>commit()</code> to the point where it is safely stored in the database.</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Proxy
    participant Resolver
    participant Log Server
    participant Storage Server

    Client-&gt;&gt;+Proxy: commit(read_set, write_set)
    Proxy-&gt;&gt;Proxy: 1. Get Read Version
    Proxy-&gt;&gt;+Resolver: 2. Resolve(read_version, read_set, write_set)
    Resolver--&gt;&gt;-Proxy: OK (no conflicts)
    Proxy-&gt;&gt;+Log Server: 3. Log(commit_version, write_set)
    Log Server--&gt;&gt;-Proxy: 4. Durable
    Proxy--&gt;&gt;-Client: 5. Commit Successful
    loop Later
        Storage Server-&gt;&gt;+Log Server: Pull mutations
        Log Server--&gt;&gt;-Storage Server: Mutations
        Storage Server-&gt;&gt;Storage Server: Apply to B-Tree
    end
</pre>
<h3 id="the-steps-of-a-commit"><a class="header" href="#the-steps-of-a-commit">The Steps of a Commit</a></h3>
<ol>
<li>
<p><strong>Get Read Version:</strong> When the transaction is ready to be committed, the client library sends it to a <strong>Proxy</strong>. The first thing the Proxy does is request a <strong>Read Version</strong> from the Cluster Controller. This version number establishes the logical point in time at which the transaction's reads occurred.</p>
</li>
<li>
<p><strong>Conflict Resolution:</strong> The Proxy sends the transaction's Read Version, its <em>read set</em> (the list of keys it read), and its <em>write set</em> to the <strong>Resolver</strong>. The Resolver checks if any of the keys in the read set have been written to by another transaction that committed <em>after</em> this transaction's Read Version. If a conflict is detected, the Resolver tells the Proxy to reject the transaction, and the client must retry.</p>
</li>
<li>
<p><strong>Logging for Durability:</strong> If the Resolver finds no conflicts, the Proxy assigns the transaction a <strong>Commit Version</strong> (which will be higher than its Read Version) and sends the transaction's <em>write set</em> (the keys and values to be written) to the <strong>Log Servers</strong>.</p>
</li>
<li>
<p><strong>Durable Commit:</strong> The Log Servers write the transaction's mutations to their durable, on-disk transaction logs. Once a quorum of Log Servers has confirmed that the data is safely on disk, they respond to the Proxy. At this point, the transaction is considered <strong>durable</strong>. Even if the entire cluster lost power, the transaction would be recovered.</p>
</li>
<li>
<p><strong>Success!</strong> The Proxy, having received confirmation from the Log Servers, reports back to the client that the commit was successful.</p>
</li>
</ol>
<h3 id="the-final-step-data-storage"><a class="header" href="#the-final-step-data-storage">The Final Step: Data Storage</a></h3>
<p>Notice that the <strong>Storage Servers</strong> were not involved in the critical commit path. This is a key design decision that makes commits extremely fast.</p>
<p>After the transaction is durable, the Storage Servers will eventually pull the new data from the Log Servers and apply the mutations to their own on-disk B-trees. This process happens asynchronously in the background and does not block new incoming transactions. This separation of the transaction log from the primary data store is a pattern known as Command Query Responsibility Segregation (CQRS) and is fundamental to FoundationDB's performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-read-path"><a class="header" href="#the-read-path">The Read Path</a></h1>
<ul>
<li><a href="internals/the-read-path.html#the-steps-of-a-read">The Steps of a Read</a></li>
<li><a href="internals/the-read-path.html#key-takeaways">Key Takeaways</a></li>
</ul>
<p>FoundationDB's read path is designed to be highly scalable and efficient. Unlike the write path, which is coordinated through a central set of proxies, the read path is almost entirely decentralized. This allows the cluster to serve a massive number of concurrent reads without creating bottlenecks.</p>
<p>Here is a high-level overview of how a read operation works:</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Proxy
    participant Storage Server

    Client-&gt;&gt;+Proxy: 1. Get Read Version
    Proxy--&gt;&gt;-Client: read_version
    Client-&gt;&gt;Client: 2. Locate Storage Server (from cache)
    Client-&gt;&gt;+Storage Server: 3. Read(key, read_version)
    Storage Server--&gt;&gt;-Client: Value
</pre>
<h3 id="the-steps-of-a-read"><a class="header" href="#the-steps-of-a-read">The Steps of a Read</a></h3>
<ol>
<li>
<p><strong>Get Read Version:</strong> When a client begins a transaction, the first thing it does is request a <strong>Read Version</strong> from a <strong>Proxy</strong>. This version is a timestamp that represents a consistent, immutable snapshot of the entire database. All reads within the transaction will be served from this snapshot, which is the foundation of FoundationDB's snapshot isolation.</p>
</li>
<li>
<p><strong>Locate the Storage Server:</strong> The client library maintains a local cache that maps key ranges to the <strong>Storage Servers</strong> responsible for them. When the client needs to read a key, it uses this cache to determine which Storage Server to contact. This lookup is extremely fast and does not require a network round-trip.</p>
</li>
<li>
<p><strong>Read from the Storage Server:</strong> The client connects directly to the appropriate Storage Server and requests the value for the key at the transaction's Read Version. The Storage Server uses its in-memory B-tree and on-disk data files to find the correct version of the value and return it to the client.</p>
</li>
</ol>
<h3 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h3>
<ul>
<li><strong>Decentralized and Scalable:</strong> Because clients read directly from Storage Servers, read throughput can be scaled horizontally simply by adding more Storage Servers to the cluster.</li>
<li><strong>Snapshot Isolation:</strong> The use of a Read Version ensures that a transaction sees a perfectly consistent view of the database, even as other transactions are being committed concurrently. Your reads are never "dirty."</li>
<li><strong>Low Latency:</strong> By caching the mapping of keys to Storage Servers, the client can avoid extra network hops and read data with very low latency.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
