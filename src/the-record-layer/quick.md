# QuiCK: A Queuing System in CloudKit

QuiCK is a distributed, transactional queuing system developed for and integrated into Apple's CloudKit. It is built on top of FoundationDB and the Record Layer. Its primary purpose is to reliably manage deferred, asynchronous tasks that are generated by CloudKit operations, such as updating search indexes, sending push notifications, or performing data compaction.

## The Challenge: Queuing at CloudKit Scale

CloudKit needed a way to manage a massive volume of asynchronous tasks without using a separate, external queuing system. Using an external system like Kafka or RabbitMQ presented several major challenges:

1.  **No Transactionality**: It's impossible to have a single atomic transaction that spans both CloudKit's database (FDB) and an external queue. For example, if a user shares a Keynote document, the system must both update access permissions in the database and enqueue a task to send a push notification. Without a transactional queue, the database update could succeed while the task enqueue fails, leaving collaborators unaware of the share.

2.  **Data Migration**: CloudKit frequently moves user data between FDB clusters for load balancing. If a user's tasks were in a separate system, this would create a coordination nightmare. For example, if a user deletes a folder in iCloud Drive and their database is then moved to a new datacenter, their queued deletion task could be left behind, unable to find the data it's supposed to act on.

3.  **Tenancy Mismatch**: CloudKit has a fine-grained tenancy model with billions of logical databases (one for each user of each app). Traditional queuing systems are designed for thousands of topics, not billions. Mapping the CloudKit model to a traditional queue would be impossible.

4.  **Operational Complexity**: An external system would be another massive, stateful service to provision, monitor, and operate alongside the hundreds of FDB clusters that power CloudKit.

To solve these issues, the team built QuiCK directly into CloudKit, storing queued tasks right alongside the user data they pertain to.

## Core Design and Technical Features

QuiCK's design overcomes the traditional concerns of building a queue on a database (like hotspots and consumer contention) through several key innovations.

### Two-Level Sharding

QuiCK avoids hotspots by sharding at an extreme scale:

*   **Level 1: Queue Zones**: The primary level of sharding consists of tens of billions of individual queues, called **Queue Zones**. Each tenant (a user of a CloudKit app) gets their own queue within their logical database. This means one tenant's activity can never create a hotspot that affects another.

*   **Level 2: Cluster Queues**: To help consumers find work efficiently, a second, higher-level queue exists on each FDB cluster. When a task is first enqueued into a tenant's previously empty Queue Zone, the same transaction also adds a **pointer** to that zone into the higher-level Cluster Queue. Consumers poll the Cluster Queue to find these pointers, which efficiently leads them to tenants with work to be done.

### Fault-Tolerant Leases via Vesting Time

To prevent multiple consumers from processing the same item, QuiCK uses a clever, fault-tolerant leasing mechanism. Instead of locking or immediately deleting an item, a consumer takes a lease by updating the item's **vesting time** to some point in the future (e.g., 5 minutes from now). This makes the item invisible to other consumers for the duration of the lease. If the consumer processes the item successfully, it deletes it. If the consumer crashes, the lease simply expires, and the item automatically becomes visible again for another consumer to pick up.

### Polling for Fairness and Efficiency

Given the massive number of queues, a push-based model is not feasible. Instead, QuiCK uses a polling-based model where a shared pool of consumers asks for work when they have capacity. This allows QuiCK to implement scheduling and fairness policies, deciding which queue to service next based on tenant priority or resource usage, preventing a single user from starving others.

### Leveraging FoundationDB and the Record Layer

QuiCK is a powerful example of building a complex subsystem on top of the FDB/Record Layer stack:

*   **Transactional Integrity**: Enqueuing a task and adding a pointer to the cluster queue are atomic operations within a standard FDB transaction.
*   **Exactly-Once Semantics**: For tasks that only modify the database (no external side effects), QuiCK can achieve exactly-once semantics by processing the task and deleting it from the queue within a single transaction.
*   **Indexed Queues**: The Record Layer's secondary indexes are used to order items within a Queue Zone by priority and vesting time, so consumers always process the most important item first.

## Further Reading

*   **Paper**: [QuiCK: A Queuing System in CloudKit](https://www.foundationdb.org/files/QuiCK.pdf) (SIGMOD '21)
*   **Video**: [QuiCK: A Queuing System in CloudKit](https://www.youtube.com/watch?v=I9mNENkZT90) (SIGMOD '21)
